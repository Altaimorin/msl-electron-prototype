// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

/**
 * This file was generated with the `generate-red-worker-code.js` script.
 */

/**
 * Insertable Stream worker worker code string.
 */
// eslint-disable-next-line
const InsertableStreamWorkerWorkerCode = "class InsertableStreamWorker {\n    constructor() {\n        this.useCryptoOffset = true;\n        this.currentKeyIdentifier = 0;\n        this.scount = 0;\n        this.rcount = 0;\n        this.frameTypeToCryptoOffset = {\n            key: 10,\n            delta: 3,\n            undefined: 1,\n        };\n    }\n    dump(encodedFrame, direction, max = 16) {\n        console.log('*** dump::direction:', direction);\n        const data = new Uint8Array(encodedFrame.data);\n        let bytes = '';\n        for (let j = 0; j < data.length && j < max; j++) {\n            bytes += (data[j] < 16 ? '0' : '') + data[j].toString(16) + ' ';\n        }\n        const metadata = encodedFrame.getMetadata();\n        console.log(performance.now().toFixed(2), direction, bytes.trim(), 'len=' + encodedFrame.data.byteLength, 'type=' + (encodedFrame.type || 'audio'), 'ts=' + encodedFrame.timestamp, 'ssrc=' + metadata.synchronizationSource, 'pt=' + (metadata.payloadType || '(unknown)'), 'mimeType=' + (metadata.mimeType || '(unknown)'));\n    }\n    encodeFunction(encodedFrame, controller) {\n        if (this.scount++ < 30) {\n            // dump the first 30 packets.\n            this.dump(encodedFrame, 'send');\n        }\n        if (this.currentCryptoKey) {\n            const view = new DataView(encodedFrame.data);\n            // Any length that is needed can be used for the new buffer.\n            const newData = new ArrayBuffer(encodedFrame.data.byteLength + 5);\n            const newView = new DataView(newData);\n            const frameTypeToCryptoOffset = this.frameTypeToCryptoOffset;\n            const cryptoOffset = this.useCryptoOffset\n                ? frameTypeToCryptoOffset[encodedFrame.type]\n                : 0;\n            for (let i = 0; i < cryptoOffset && i < encodedFrame.data.byteLength; ++i) {\n                newView.setInt8(i, view.getInt8(i));\n            }\n            // This is a bitwise xor of the key with the payload. This is not strong encryption, just a demo.\n            for (let i = cryptoOffset; i < encodedFrame.data.byteLength; ++i) {\n                const keyByte = this.currentCryptoKey.charCodeAt(i % this.currentCryptoKey.length);\n                newView.setInt8(i, view.getInt8(i) ^ keyByte);\n            }\n            // Append keyIdentifier.\n            newView.setUint8(encodedFrame.data.byteLength, this.currentKeyIdentifier % 0xff);\n            // Append checksum\n            newView.setUint32(encodedFrame.data.byteLength + 1, 0xdeadbeef);\n            encodedFrame.data = newData;\n        }\n        controller.enqueue(encodedFrame);\n    }\n    decodeFunction(encodedFrame, controller) {\n        if (this.rcount++ < 30) {\n            // dump the first 30 packets\n            this.dump(encodedFrame, 'recv');\n        }\n        const view = new DataView(encodedFrame.data);\n        const checksum = encodedFrame.data.byteLength > 4 ? view.getUint32(encodedFrame.data.byteLength - 4) : false;\n        if (this.currentCryptoKey) {\n            if (checksum !== 0xdeadbeef) {\n                console.log('Corrupted frame received, checksum ' + checksum.toString(16));\n                return; // This can happen when the key is set and there is an unencrypted frame in-flight.\n            }\n            const keyIdentifier = view.getUint8(encodedFrame.data.byteLength - 5);\n            if (keyIdentifier !== this.currentKeyIdentifier) {\n                console.log(`Key identifier mismatch, got ${keyIdentifier} expected ${this.currentKeyIdentifier}.`);\n                return;\n            }\n            const newData = new ArrayBuffer(encodedFrame.data.byteLength - 5);\n            const newView = new DataView(newData);\n            const frameTypeToCryptoOffset = this.frameTypeToCryptoOffset;\n            const cryptoOffset = this.useCryptoOffset\n                ? frameTypeToCryptoOffset[encodedFrame.type]\n                : 0;\n            for (let i = 0; i < cryptoOffset; ++i) {\n                newView.setInt8(i, view.getInt8(i));\n            }\n            for (let i = cryptoOffset; i < encodedFrame.data.byteLength - 5; ++i) {\n                const keyByte = this.currentCryptoKey.charCodeAt(i % this.currentCryptoKey.length);\n                newView.setInt8(i, view.getInt8(i) ^ keyByte);\n            }\n            encodedFrame.data = newData;\n        }\n        else if (checksum === 0xdeadbeef) {\n            return; // encrypted in-flight frame but we already forgot about the key.\n        }\n        controller.enqueue(encodedFrame);\n    }\n    handleTransform(operation, readable, writable) {\n        if (operation === 'encode') {\n            const transformStream = new TransformStream({\n                transform: (encodedFrame, controller) => this.encodeFunction(encodedFrame, controller),\n            });\n            readable.pipeThrough(transformStream).pipeTo(writable);\n        }\n        else if (operation === 'decode') {\n            const transformStream = new TransformStream({\n                transform: (encodedFrame, controller) => this.decodeFunction(encodedFrame, controller),\n            });\n            readable.pipeThrough(transformStream).pipeTo(writable);\n        }\n    }\n    static initializeWorker() {\n        console.log(`Insertable stream worker initializing`);\n        const worker = new InsertableStreamWorker();\n        self.onmessage = (event) => {\n            if (event.data.operation === 'encode' || event.data.operation === 'decode') {\n                return worker.handleTransform(event.data.operation, event.data.readable, event.data.writable);\n            }\n            if (event.data.operation === 'setCryptoKey') {\n                if (event.data.currentCryptoKey !== worker.currentCryptoKey) {\n                    worker.currentKeyIdentifier++;\n                }\n                worker.currentCryptoKey = event.data.currentCryptoKey;\n                worker.useCryptoOffset = event.data.useCryptoOffset;\n            }\n        };\n        // @ts-ignore\n        if (self.RTCTransformEvent) {\n            // @ts-ignore\n            self.onrtctransform = event => {\n                const transformer = event.transformer;\n                worker.handleTransform(transformer.options.operation, transformer.readable, transformer.writable);\n            };\n        }\n    }\n}\nInsertableStreamWorker.initializeWorker();\n";

export default InsertableStreamWorkerWorkerCode;
